// Generated by CoffeeScript 1.9.1
var Image, S3, Upload, deprecate, fs, gm, hash, mapLimit, rand;

S3 = require('aws-sdk').S3;
fs = require('fs');
gm = require('gm').subClass({
  imageMagick: true
});
mapLimit = require('async').mapLimit;
hash = require('crypto').createHash;
rand = require('crypto').pseudoRandomBytes;
deprecate = require('depd')('s3-uploader');

Upload = module.exports = function(awsBucketName, opts1) {
  var base, base1, base10, base11, base12, base13, base14, base15, base16, base17, base2, base3, base4, base5, base6, base7, base8, base9;
  this.opts = opts1 != null ? opts1 : {};
  if (!awsBucketName) {
    throw new TypeError('Bucket name can not be undefined');
  }
  if (this.opts.awsBucketRegion) {
    deprecate('`awsBucketRegion` is deprecated, use `aws.region` instead');
  }
  if (this.opts.awsBucketPath) {
    deprecate('`awsBucketPath` is deprecated, use `aws.path` instead');
  }
  if (this.opts.awsBucketAcl) {
    deprecate('`awsBucketAcl` is deprecated, use `aws.acl` instead');
  }
  if (this.opts.awsMaxRetries) {
    deprecate('`awsMaxRetries` is deprecated, use `aws.maxRetries` instead');
  }
  if (this.opts.awsHttpTimeout) {
    deprecate('`awsHttpTimeout` is deprecated, use `aws.httpOptions.timeout` instead');
  }
  if (this.opts.awsAccessKeyId) {
    deprecate('`awsAccessKeyId` is deprecated, use `aws.accessKeyId` instead');
  }
  if (this.opts.awsSecretAccessKey) {
    deprecate('`awsSecretAccessKey` is deprecated, use `aws.secretAccessKey` instead');
  }
  if ((base = this.opts).aws == null) {
    base.aws = {};
  }
  if ((base1 = this.opts.aws).region == null) {
    base1.region = this.opts.awsBucketRegion || 'us-east-1';
  }
  if ((base2 = this.opts.aws).path == null) {
    base2.path = this.opts.awsBucketPath || '';
  }
  if ((base3 = this.opts.aws).acl == null) {
    base3.acl = this.opts.awsBucketAcl || 'private';
  }
  if ((base4 = this.opts.aws).sslEnabled == null) {
    base4.sslEnabled = true;
  }
  if ((base5 = this.opts.aws).maxRetries == null) {
    base5.maxRetries = this.opts.awsMaxRetries || 3;
  }
  if ((base6 = this.opts.aws).accessKeyId == null) {
    base6.accessKeyId = this.opts.awsAccessKeyId;
  }
  if ((base7 = this.opts.aws).secretAccessKey == null) {
    base7.secretAccessKey = this.opts.awsSecretAccessKey;
  }
  if ((base8 = this.opts.aws).params == null) {
    base8.params = {};
  }
  this.opts.aws.params.Bucket = awsBucketName;
  if ((base9 = this.opts.aws).httpOptions == null) {
    base9.httpOptions = {};
  }
  if ((base10 = this.opts.aws.httpOptions).timeout == null) {
    base10.timeout = this.opts.awsHttpTimeout || 10000;
  }
  if ((base11 = this.opts).versions == null) {
    base11.versions = [];
  }
  if ((base12 = this.opts).resizeQuality == null) {
    base12.resizeQuality = 70;
  }
  if ((base13 = this.opts).returnExif == null) {
    base13.returnExif = false;
  }
  if ((base14 = this.opts).tmpDir == null) {
    base14.tmpDir = require('os').tmpdir() + '/';
  }
  if ((base15 = this.opts).tmpPrefix == null) {
    base15.tmpPrefix = 'gm-';
  }
  if ((base16 = this.opts).workers == null) {
    base16.workers = 1;
  }
  if ((base17 = this.opts).url == null) {
    base17.url = "https://s3-" + this.opts.aws.region + ".amazonaws.com/" + this.opts.aws.params.Bucket + "/";
  }
  this.s3 = new S3(this.opts.aws);
  return this;
};

Upload.prototype._getRandomPath = function() {
  var i, input, j, res, x, y;
  input = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  res = [];
  for (i = j = 1; j <= 3; i = ++j) {
    x = input[Math.floor(Math.random() * input.length)];
    y = input[Math.floor(Math.random() * input.length)];
    res.push(x + y);
  }
  return res.join('/');
};

Upload.prototype._uploadPathIsAvailable = function(path, callback) {
  return this.s3.listObjects({
    Prefix: path
  }, function(err, data) {
    if (err) {
      return callback(err);
    }
    return callback(null, path, data.Contents.length === 0);
  });
};

Upload.prototype._uploadGeneratePath = function(prefix, callback) {
  return this._uploadPathIsAvailable(prefix + this._getRandomPath(), function(err, path, avaiable) {
    if (err) {
      return callback(err);
    }
    if (!avaiable) {
      return callback(new Error("Path '" + path + "' not avaiable!"));
    }
    return callback(null, path);
  });
};

Upload.prototype.upload = function(src, opts, cb) {
  var prefix;
  prefix = (opts != null ? opts.awsPath : void 0) || this.opts.aws.path;
  return this._uploadGeneratePath(prefix, (function(_this) {
    return function(err, dest) {
      if (err) {
        return cb(err);
      }
      return new Image(src, dest, opts, _this).exec(cb);
    };
  })(this));
};

Image = Upload.Image = function(src, dest, opts, config) {
  this.config = config;
  this.src = src;
  this.dest = dest;
  this.tmpName = hash('sha1').update(rand(128)).digest('hex');
  this.opts = opts || {};
  this.meta = {};
  this.gm = gm(this.src);
  return this;
};

Image.prototype.getMeta = function(cb) {
  return this.gm.identify((function(_this) {
    return function(err, val) {
      if (err) {
        return cb(err);
      }
      _this.meta = {
        format: val.format.toLowerCase(),
        fileSize: val.Filesize,
        imageSize: val.size,
        orientation: val.Orientation,
        colorSpace: val.Colorspace,
        compression: val.Compression,
        quallity: val.Quality,
        exif: _this.config.opts.returnExif ? val.Properties : void 0
      };
      return cb(null, _this.meta);
    };
  })(this));
};

Image.prototype.makeMpc = function(cb) {
  var self = this;
  return this.gm.write(this.src + '.mpc', function(err) {
    if (err) {
      return cb(err);
    }
    self.gm = gm(self.src + '.mpc');
    return cb(null);
  });
};

Image.prototype.resize = function(version, cb) {
  var img, ref;
  if (typeof version.original !== 'undefined') {
    if (version.original === false) {
      throw new Error("version.original can not be false");
    }
    version.src = this.src;
    version.format = this.meta.format;
    version.size = this.meta.fileSize;
    version.width = this.meta.imageSize.width;
    version.height = this.meta.imageSize.height;
    return process.nextTick(function() {
      return cb(null, version);
    });
  }
  version.format = 'jpeg';
  version.src = [this.config.opts.tmpDir, this.config.opts.tmpPrefix, this.tmpName, version.suffix, "." + version.format].join('');
  img = this.gm.resize(version.maxWidth, version.maxHeight).quality(version.quality || this.config.opts.resizeQuality);
  if (this.meta.orientation) {
    img.autoOrient();
  }
  if ((ref = this.meta.colorSpace) !== 'RGB' && ref !== 'sRGB') {
    img.colorspace('RGB');
  }
  return img.write(version.src, function(err) {
    if (err) {
      return cb(err);
    }
    version.width = version.maxWidth;
    delete version.maxWidth;
    version.height = version.maxHeight;
    delete version.maxHeight;
    return cb(null, version);
  });
};

Image.prototype.upload = function(version, cb) {
  var options;
  options = {
    Key: this.dest + version.suffix + '.' + version.format,
    ACL: version.awsImageAcl || this.config.opts.aws.acl,
    Body: fs.createReadStream(version.src),
    ContentType: 'image/' + version.format,
    Metadata: this.opts.metadata || {}
  };
  return this.config.s3.putObject(options, (function(_this) {
    return function(err, data) {
      if (err) {
        return cb(err);
      }
      version.etag = data.ETag.substr(1, data.ETag.length - 2);
      version.path = options.Key;
      if (_this.config.opts.url) {
        version.url = _this.config.opts.url + version.path;
      }
      delete version.awsImageAcl;
      delete version.suffix;
      return cb(null, version);
    };
  })(this));
};

Image.prototype.resizeAndUpload = function(version, cb) {
  version.suffix = version.suffix || '';
  return this.resize(version, (function(_this) {
    return function(err, version) {
      if (err) {
        return cb(err);
      }
      return _this.upload(version, cb);
    };
  })(this));
};

Image.prototype.exec = function(cb) {
  return this.getMeta((function(_this) {
    return function(err) {
      return _this.makeMpc(function(err) {
        var versions;
        if (err) {
          return cb(err);
        }
        versions = JSON.parse(JSON.stringify(_this.config.opts.versions));
        return mapLimit(versions, _this.config.opts.workers, _this.resizeAndUpload.bind(_this), function(err, versions) {
          if (err) {
            return cb(err);
          }
          return cb(null, versions, _this.meta);
        });
      });
    };
  })(this));
};
